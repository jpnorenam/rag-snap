package knowledge

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/jpnorenam/rag-snap/cmd/cli/common"
)

// Document represents a single document to be indexed into OpenSearch.
// Fields match the KNN index mapping (embedding is generated by the ingest pipeline).
type Document struct {
	Content   string `json:"content"`
	SourceID  string `json:"source_id"`
	CreatedAt string `json:"created_at"`
}

// BulkResult contains statistics about a completed bulk indexing operation.
type BulkResult struct {
	Total   int
	Indexed int
	Errors  int
}

// BulkIndex indexes documents into the specified OpenSearch index
// using the bulk API with the ingest pipeline for embedding generation.
func (c *OpenSearchClient) BulkIndex(ctx context.Context, indexName string, documents []Document) (*BulkResult, error) {
	stopProgress := common.StartProgressSpinner(fmt.Sprintf("Indexing %d chunks", len(documents)))
	defer stopProgress()

	return c.bulkIndex(ctx, indexName, documents)
}

func (c *OpenSearchClient) bulkIndex(ctx context.Context, indexName string, documents []Document) (*BulkResult, error) {
	var buf bytes.Buffer
	for _, doc := range documents {
		action := map[string]any{
			"index": map[string]any{
				"_index": indexName,
			},
		}
		actionJSON, err := json.Marshal(action)
		if err != nil {
			return nil, fmt.Errorf("marshaling action: %w", err)
		}
		buf.Write(actionJSON)
		buf.WriteByte('\n')

		docJSON, err := json.Marshal(doc)
		if err != nil {
			return nil, fmt.Errorf("marshaling document: %w", err)
		}
		buf.Write(docJSON)
		buf.WriteByte('\n')
	}

	path := fmt.Sprintf("/_bulk?pipeline=%s", ingestPipelineName)
	req, err := c.newAuthenticatedRequest(http.MethodPost, path, &buf)
	if err != nil {
		return nil, fmt.Errorf("creating bulk request: %w", err)
	}
	req.Header.Set("Content-Type", "application/x-ndjson")

	resp, err := c.client.Client.Perform(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("bulk request failed: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading bulk response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("bulk request returned status %d: %s", resp.StatusCode, string(body))
	}

	var bulkResp struct {
		Errors bool `json:"errors"`
		Items  []struct {
			Index struct {
				Status int `json:"status"`
				Error  any `json:"error"`
			} `json:"index"`
		} `json:"items"`
	}

	if err := json.Unmarshal(body, &bulkResp); err != nil {
		return nil, fmt.Errorf("parsing bulk response: %w", err)
	}

	result := &BulkResult{
		Total: len(documents),
	}
	for _, item := range bulkResp.Items {
		if item.Index.Status >= 200 && item.Index.Status < 300 {
			result.Indexed++
		} else {
			result.Errors++
		}
	}

	return result, nil
}
